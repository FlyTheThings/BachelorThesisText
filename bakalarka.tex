%% LyX 2.1.4 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[a4paper,twoside,english,cleardoublepage=empty,BCOR15mm,DIV12]{scrreprt}
\usepackage{amsmath}
\usepackage{tgtermes}
\usepackage{tgheros}
\usepackage{tgcursor}
\usepackage{newtxmath}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{float}
\usepackage{graphicx}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\pdfpageheight\paperheight
\pdfpagewidth\paperwidth

\newcommand{\noun}[1]{\textsc{#1}}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}[chapter]
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
%<-------------------------------společná nastavení------------------------------>
\usepackage[numbers,sort&compress]{natbib} %balíček pro citace literatury  
\usepackage{algorithmic}
\usepackage{color}%kvůli barvám ČVUT
\newcommand{\BibTeX}{{\sc Bib}\TeX}%BibTeX logo
\usepackage{multicol}
\usepackage[overload]{textcase}



%<-----------------------------volání stylů----------------------------------------->
% (znak % je označení komentáře: co je za ním, není aktivní)

%<--------matematické písmo--------------------------------------->

%\usepackage[helvet]{packages/sfmath}%matematika ala helvetica



%<------------------------------záhlaví stránek------------------------------------>
%\usepackage{packages/bc-headings}
\usepackage{packages/bc-fancyhdr}

%<------------------------------hlavičky kapitol------------------------------------>
%\usepackage{packages/bc-neueskapitel}
\usepackage{packages/bc-fancychap}

\makeatother

\begin{document}
~\thispagestyle{empty}\begin{center}\pagenumbering{roman}\vspace{10mm}


\textsf{\textsc{\noun{\LARGE{}Czech Technical University in Prague}}}\\
\vspace{0.5em}
\textsf{\textsc{\noun{\LARGE{}Fakulty of Electrical Engineering}}}\\
\vspace*{1em}
\textsf{\textsc{\noun{\Large{}Department of Cybernetics}}}\vspace{15mm}


\includegraphics[width=0.3\textwidth]{obrazky/lev}\vspace{15mm}


\textsf{\huge{}BACHELOR THESIS}{\huge \par}

\vspace{15mm}


\textsf{\LARGE{}Název práce}{\LARGE \par}

\vspace{10mm}


\end{center} 

\vspace*{\fill}


\vspace{10mm}

\begin{description}
\item [{{\large{}Autor:}}] \noindent \textsf{\large{}Matěj Račinský}{\large \par}
\item [{{\large{}Thesis~supervisor:}}] \noindent \textsf{\large{}Dr. Martin
Saska}{\large{}\hfill{}}\textsf{\large{}In Prague,}{\large{} \the\year % nebo doplňte rok vzniku vaší bakalářské práce
}{\large \par}
\end{description}
\clearpage{}

{\small{}\thispagestyle{plain}\addcontentsline{toc}{chapter}{Abstrakt} }{\small \par}

\noindent {\small{}~\vfill{}
}{\small \par}
\begin{description}
\item [{{\small{}Název~práce:}}] \noindent {\small{}Název bakalářské práce}{\small \par}
\item [{{\small{}Autor:}}] \noindent {\small{}Matěj Račinský}{\small \par}
\item [{{\small{}Katedra~(ústav):}}] \noindent Kate{\small{}dra kybernetiky}{\small \par}
\item [{{\small{}Vedoucí~bakalářské~práce:}}] \noindent Dr. Martin Saska
\item [{{\small{}e-mail~vedoucího:}}] \noindent {\small{}saska@labe.felk.cvut.cz}\\
{\small \par}
\item [{{\small{}Abstrakt}}] \noindent {\small{}V předložené práci studujeme...
Uvede se abstrakt v rozsahu 80 až 200 slov. Lorem ipsum dolor sit
amet, consectetuer adipiscing elit. Ut sit amet sem. Mauris nec turpis
ac sem mollis pretium. Suspendisse neque massa, suscipit id, dictum
in, porta at, quam. Nunc suscipit, pede vel elementum pretium, nisl
urna sodales velit, sit amet auctor elit quam id tellus. Nullam sollicitudin.}{\small \par}
\item [{{\small{}Klíčová~slova:}}] \noindent {\small{}klíčová slova (3
až 5)}\\
{\small \par}
\item [{\rule[0.5ex]{1\linewidth}{1pt}}]~{\small \par}
\item [{{\small{}Title:}}] \noindent {\small{}Název bakalářské práce v
angličtině}{\small \par}
\item [{{\small{}Author:}}] \noindent {\small{}Matěj Račinský}{\small \par}
\item [{{\small{}Department:}}] \noindent {\small{}Department of Cybernetics}{\small \par}
\item [{{\small{}Supervisor:}}] \noindent Dr. Martin Saska
\item [{{\small{}Supervisor's~e-mail~address:}}] \noindent {\small{}saska@labe.felk.cvut.cz}\\
{\small \par}
\item [{{\small{}Abstract}}] \noindent {\small{}In the present work we
study ... Uvede se anglický abstrakt v rozsahu 80 až 200 slov. Lorem
ipsum dolor sit amet, consectetuer adipiscing elit. Ut sit amet sem.
Mauris nec turpis ac sem mollis pretium. Suspendisse neque massa,
suscipit id, dictum in, porta at, quam. Nunc suscipit, pede vel elementum
pretium, nisl urna sodales velit, sit amet auctor elit quam id tellus.
Nullam sollicitudin. Donec hendrerit. Aliquam ac nibh. Vivamus mi.
Sed felis. Proin pretium elit in neque. Pellentesque at turpis. Maecenas
convallis. Vestibulum id lectus. }{\small \par}
\item [{{\small{}Keywords:}}] \noindent {\small{}klíčová slova (3 až 5)
v angličtině}{\small \par}
\end{description}
\cleardoublepage{}\thispagestyle{empty}~{\small{}\addcontentsline{toc}{chapter}{Zadání
práce} }{\small \par}

\thispagestyle{plain}

{\small{}%\setcounter{page}{3} % nastavení číslování stránek
\ }{\small \par}

\noindent {\small{}\vfill{}
 % nastavuje dynamické umístění následujícího textu do spodní části stránky
~}{\small \par}

\noindent {\small{}Prohlašuji, že jsem svou bakalářskou práci napsal(a)
samostatně a výhradně s použitím citovaných pramenů. Souhlasím se
zapůjčováním práce a jejím zveřejňováním.}{\small \par}

{\small{}\bigskip{}
}\noindent {\small{} V Praze dne \today\hspace{\fill}Jméno Příjmení
+ podpis}\\
{\small{} % doplňte patřičné datum, jméno a příjmení
}{\small \par}

{\small{}%%%   Výtisk pak na tomto míste nezapomeňte PODEPSAT!
%%%                                         *********
}{\small \par}

{\small{}\tableofcontents{}% vkládá automaticky generovaný obsah dokumentu
}{\small \par}


\chapter[Algorithm]{Algorithm\label{chap:Algorithm}}

Basis of whole algorithm is here in pseudocode

\begin{algorithm}
\caption{Basis of whole algorithm}


\begin{algorithmic}[1]

\STATE map := configuration.getMap();

\STATE map := amplifyObstacles(map);

\STATE nodes := mapToNodes(map);

\STATE paths := createGuidingPaths(nodes);

\STATE rrtPath := rrtPath(paths, map, nodes);

\STATE lastState := getBestFitness(rrtPath, map);

\STATE path := getPath(lastState);

\STATE path = straightenCrossingTrajectories(path);

\STATE path := optimizePathByDubins(path, map);

\STATE savePathToJson(path);

\end{algorithmic}
\end{algorithm}


Configuration variable is instance of Configuration class, which holds
all configuration variables, including selected map. Map holds all
Aeras of Interest (AoI) and obstacles. All obstacles and AoIs are
represented now as rectangles.

Even if we want to find as short path to AoI as possible, path too
near to obstacles is not convenient for realization, because UAVs
do not use car like motion model used in this simulation, so they
can not exactly follow found trajectories. So in real environment,
it is convenient for the swarm to have path planned with safe distance
from obstacles. Because of that fact, we need to increase size od
obstacles, which is done in line 2 in function amplifyObstacles. 

Line 3 represents discretization of map to graph. Discretizaion divides
map to squares with size set in configuration and eac square is represented
by node. In this graph, there are 4 types of nodes: Free, Obstacle,
UAV and Goal. If part of square of whole square is covered by obstacle,
corresponding node has type Obstacle. If part of square or whole square
is covered by AoI, corresponding node has type Goal. If square contains
UAV, corresponding node has type UAV and rest of squares have corresponding
nodes qith type Free. 

Edges in this graph are only between nodes of neighboring squares,
so each node has maximally 8 edges. Obstacle nodes do not have any
edges.

After converting map to nodes, optional grouping of goals for guiding
path can be turned on. I will cover the grouping in chapter \ref{chap:Grouping-of-goals}.

Line 4 calculates the guiding paths for rrt path algorithm using the
A{*} algorithm. Algorithm has modified cost function and in addition
to cost function of A{*} algorithm, cost of current node is added
during the calculation. Nodes neighboring with obstacles has bigger
cost than nodes which do not have obstacles as neighbors. Thanks to
this modification, guiding path avoids obstacles and has bigger distance
to obstacles. 

On line 5 the rrt path algoritm takes place. This function returns
structure with tree with root at starting position of UAVs and with
array containing leaves of this three, where all UAVs are in Areas
of Interest. 

On line 6 the leaf, where UAVs have best coverage of AoI is chosen.
Quality of coverage is determined by cost function, which will be
mentioned later.\marginpar{todo: možná sem odkaz na kapitolu}

On line 7 the path is built from last state.

On line 8 is optional preparation before optimization using Dubins
maneuvers. In the preperation, all crossings of paths of individual
UAVs are straigtened, so UAVs do not cross other UAVs trajectories
during whole path. During implementation of this method were complications,
which are covered in chapter, and thus the row was removed from the
algorithm. \ref{chap:Paths-narrowing}

On line 9 is optimization by Dubins maneuvers. Optimizations is covered
in chapter.\marginpar{todo: možná sem odkaz na kapitolu}

Last line is only persisting of path to file for usage of path by
different program.


\chapter[Grouping of goals for guiding path]{ Grouping of goals for guiding path \label{chap:Grouping-of-goals}}

During this processing of map (method MapProcessor::getEndNodes in
codebase) all AoIs are grouped to one big AoI, which is the smallest
rectangle covering all AoIs. 

If this modification is turned on, instead of one goal for every AoI
(node in middle of AoI rectangle is considered as goal node), only
one goal is used for all AoIs. This prevents swarm to split and whole
swarm has only one guiding path. The main reason to have one big swarm
instead of more smaller swarms is that smaller swarms (or individual
UAVs in case of same count of AoI and UAVs) is relative localization,
which can be used better when having only one swarm.

Below are images of maps with goals and obstacles. Goals have grren
color and obstacles have grey color.

This approach has advantage, when individual AoIs are near to global
goal of whole gorup, as seen in \ref{fig:Maps-with-goals}. 

Disadvantage of this method is, when individual AoIs have big distance
from each other than can be covered by UAVs, this approach totally
fails, because RRT-Path, which is much faster than RRT, has goal very
distant from AoIs, as can be seen in \ref{fig:Map-with-goals}.

\begin{figure}
\includegraphics[scale=0.3]{obrazky/map1}

\caption{Map with goals unsuitable for grouping \label{fig:Map-with-goals}}
\end{figure}


\begin{figure}
\includegraphics[scale=0.3]{obrazky/map2}\includegraphics[scale=0.3]{obrazky/map5}

\caption{Maps with goals suitable for grouping \label{fig:Maps-with-goals}}
\end{figure}



\chapter[Paths narrowing]{Paths narrowing \label{chap:Paths-narrowing}}

RRT-Path algorithm checks crossing paths between neighboring states,
so between n-th state and n+1-th state no trajectories are crossing
each other. But between states trajectories are still crossing. In
this image \ref{fig:Crossing-paths} is shown path found by RRT-Path.
Every color marks one state in RRT-Path. As we can see, check in algorithm
prevents from crossing path between neighboring states, but crossing
of paths in different times can not be easily prevented. We can see
in image, that paths cross between points J (yellow), M (light green)
and H (orange), K (yellow), so there is no easy approach to prevent
path collisions between n-2-th state and n-th state. Optimization
by Dubins maneuvers shortens trajectory of UAVs, so UAVs could be
in these trajectories in different time, so there could be collisions
after optimization. Another complication occurs, when time difference
between two states is too low, then uavs could collide, because in
reality UAV can not follow path precisely, but only with some errors.

\begin{figure}


\caption{Crossing paths \label{fig:Crossing-paths}}


\includegraphics[scale=0.3]{obrazky/crossingPathReal1}
\end{figure}
I tried to straighten crossing trajectories, but all attempts failed.
Straightening was done by switching parts of crossing paths from the
earliest crossing state to end. But then paths had different leghts,
which was unsuitable for path planning for swarm. This can be done
by adding ``waiting'' points, points in different state but with
same position in different time. But then is really hard sto traighten
longer path with many crossings (this path is really short, paths
in other maps are much longer and more complicated). For motion model
with inertia is also really hard to deal with waiting states, which
complicates following of straightened trajectories. Due to all complications
mentioned above, this part was removed from algorithm. But it is possible
to add it, when better aproach will be found.


\chapter[Motion model]{Motion model}

The RRT-Path algorithm is universal and works without motion model,
which is fine for holonomic robot, but usage of motion model allows
us to find path more feasible for swarm of UAVs than without using
of holonomic robot. For this purpose, car like model was chosen. Differential
equations of motion model in 3D from \cite{MartinSaskaPreucil} are
\begin{equation}
\begin{split}\dot{x}\left(t\right) & = & v\left(t\right)\sin\varphi\left(t\right)\\
\dot{y}\left(t\right) & = & v\left(t\right)\cos\left(t\right)\\
\dot{z}\left(t\right) & = & w\left(t\right)\\
\dot{\varphi}\left(t\right) & = & K\left(t\right)v\left(t\right)
\end{split}
\end{equation}
where $x\left(t\right),y\left(t\right),z\left(t\right)$ are coordinates
of UAV, $\varphi\left(t\right)$ represents heading of UAV, $v\left(t\right)$
is forward velocity, $K\left(t\right)$ is curvature, $w\left(t\right)$
is ascent velocity. $\begin{bmatrix}K\left(t\right) & w\left(t\right) & v\left(t\right)\end{bmatrix}$
represent input vector of motion model. Differential equations are
useful for representation in equations, but not useful for computer
algorithm. For usage in algorithm are better difference equations
instead of differential equations. When inputs are held constant in
each time interval between two time steps, difference equations are
\begin{equation}
\begin{split}x\left(k+1\right) & = & \begin{cases}
x\left(k\right)+\frac{1}{K\left(k+1\right)}\left(\sin\left(\varphi\left(k\right)+K\left(k+1\right)v\left(k+1\right)\Delta t\left(k+1\right)\right)-\sin\left(\varphi\left(k\right)\right)\right) & if\,K\left(k+1\right)\neq0\\
x\left(k\right)+v\left(k+1\right)\cos\left(\varphi\left(k\right)\right)\Delta t\left(k+1\right) & if\,K\left(k+1\right)=0
\end{cases}\\
y\left(k+1\right) & = & \begin{cases}
y\left(k\right)-\frac{1}{K\left(k+1\right)}\left(\cos\left(\varphi\left(k\right)+K\left(k+1\right)v\left(k+1\right)\Delta t\left(k+1\right)\right)-\cos\left(\varphi\left(k\right)\right)\right) & if\,K\left(k+1\right)\neq0\\
y\left(k\right)+v\left(k+1\right)\sin\left(\varphi\left(k\right)\right)\Delta t\left(k+1\right) & if\,K\left(k+1\right)=0
\end{cases}\\
z\left(k+1\right) & = & z\left(k\right)+w\left(k+1\right)\Delta t\left(k+1\right)\\
\varphi\left(k+1\right) & = & \varphi\left(k\right)+K\left(k+1\right)v\left(k+1\right)\Delta t\left(k+1\right)
\end{split}
\end{equation}



\chapter[Dubins maneuvers]{Dubins maneuvers}

Dubins maneuvers, also called Dubins curves or Dubins path were published
by Lester Eli Dubins in 1957 \cite{Dubins1957}. Dubins path is optimal
path for car like motion model. Path is optimal, when car moves at
constant forward speed. The other important constraint is the maximum
steering angle $\phi_{max}$, which results in a minimum turning radius$\rho_{min}$.
As the car travels, consider the length of the curve in ${\cal W}=\mathbb{R}^{2}$
traced out by a pencil attached to the center of the car. The task
is to minimize the length of this curve as the car travels between
any $q_{I}$ and $q_{G}$. Due to $\rho_{min}$, this can be considered
as a bounded-curvature shortest-path problem. If $\rho_{min}=0$,
then there is no curvature bound, and the shortest path follows a
straight line in $\mathbb{R}^{2}$. In terms of a cost function, the
criterion to optimize is

\begin{equation}
\ensuremath{{\displaystyle L(\tilde{q},\tilde{u})=\int_{0}^{t_{F}}\sqrt{\dot{x}(t)^{2}+\dot{y}(t)^{2}}dt}}
\end{equation}
, where $t_{F}$ is the time at which $q_{G}$ is reached, and a configuration
is denoted as $q=(x,y,\theta)$, $\tilde{x}_{t}$ denotes the function
$\tilde{x}_{t}:[0,t]\rightarrow X$, which is called the state trajectory
(or state history). This is a continuous-time version of the state
history, which was defined previously for problems that have discrete
stages. Similarly, $\tilde{u}_{t}$ denotes the action trajectory
(or action history),. If $q_{G}$ is not reached, then it is assumed
that $L(\tilde{q},\tilde{u})=\infty$. \cite{LaValle2006}

When considering constraints of inputs (actions) for motion model,
the system can be simplified to

\begin{equation}
\begin{split}\dot{x} & = & \cos\theta\\
\dot{y} & = & \sin\theta\\
\dot{\theta} & = & u
\end{split}
\end{equation}


in which $u$ is chosen from the interval $U=\left\{ -\tan\phi_{max},0,\tan\phi_{max}\right\} $.
For simplicity, assume that $\tan\phi=1$. The following results also
hold for any $\phi_{max}\in(0,\pi/2)$. 

\begin{table}


\caption{The three motion primitives from which all optimal curves for the
Dubins car can be constructed. \label{tab:The-three-motion}}


\begin{tabular}{|c|c|}
\hline 
Symbol & Steering u\tabularnewline
\hline 
\hline 
L & -1\tabularnewline
\hline 
S & 0\tabularnewline
\hline 
R & 1\tabularnewline
\hline 
\end{tabular}
\end{table}


It was shown in \cite{Dubins1957} that between any two configurations,
the shortest path for the Dubins car can always be expressed as a
combination of no more than three motion primitives. Each motion primitive
applies a constant action over an interval of time. Furthermore, the
only actions that are needed to traverse the shortest paths are $u\in\{-1,0,1\}$.
The primitives and their associated symbols are shown in \ref{tab:The-three-motion}.
The $S$ primitive drives the car straight ahead. The $L$ and $R$
primitives turn as sharply as possible to the left and right, respectively.
Using these symbols, each possible kind of shortest path can be designated
as a sequence of three symbols that corresponds to the order in which
the primitives are applied. Let such a sequence be called a word .
There is no need to have two consecutive primitives of the same kind
because they can be merged into one. Under this observation, ten possible
words of length three are possible. Dubins showed that only these
six words are possibly optimal:

\begin{equation}
\ensuremath{{\displaystyle \{LRL,\;RLR,\;LSL,\;LSR,\;RSL,\;RSR\}.}}
\end{equation}


The shortest path between any two configurations can always be characterized
by one of these words. These are called the Dubins curves.


\chapter[Implementation]{Implementation}

This part will cover implementation of algorithm, which was used for
simulations. Whole codebase can be found at \href{https://github.com/racinmat/AutonomousSurveillanceBachelorThesis}{this github repository}.


\section{External libraries}

In implementation are used some external libries. Every used library
is mentioned here.\href{http://www.boost.org/}{Boost libraries} is
used for smart pointers, libraries for Dubins maneuvers are from Master
Thesis by Petr Váňa\cite{Vana2015}. Generating of JSON from C++ object
is done via \href{http://www.codeproject.com/Articles/20027/JSON-Spirit-A-C-JSON-Parser-Generator-Implemented}{Json Spirit}
library. Another external library is \href{http://gamma.cs.unc.edu/V-COLLIDE/}{V-Collide}
from The University of North Carolina at Chapel Hill. 

Because V-Collide sources were written in 1997 and because I used
C++11 compiler to compile my source codes, I had to rewrite part of
this library for compatibility and to make public API easier to use.
Modifications can be seen in \href{https://github.com/racinmat/VCollide2}{this github repository}. 

Last use external library is QT, which was used to create platform
independent GUI.


\section{Code structure and services}

Here is shown brief UML scheme demonstrating dependency diagram of
codebase. To keep diagram simple, only services are displayed, other
classes, thich are not services, were left out for lucidity. Diagram
was generated using software \href{http://staruml.io/}{StarUML}

\begin{figure}
\caption{Dependency diagram \label{fig:Dependency-diagram}}


\includegraphics[scale=0.4]{obrazky/umlSchema}
\end{figure}


Core class holds core of whole Application and has all other classes
as dependencies, as is shown in image \ref{fig:Dependency-diagram}. 

As mentioned in \ref{chap:Algorithm} chapter Configuration is DTO
for all configuration variables, but to keep reasonable amount of
classes, Configuration is also service, which delegates all configuration
changes from GUI to Core class. Configuration and GuiDrawer implementation
LoggerInterface are the only connections between Core and GUI.

State factory creates State classes according to Factory pattern.
State class represents state in RRT-Path algorithm. State has coordinates
and rotations for all UAVs.

Persister persists found path to JSON using Json Spirit library.

PathHandler serves as utils class for manipulations with path (vector
of State classes).

CarLikeMotionModel holds motion model algorithm.

InputGenerator is used to generate inputs to motion model.

NTupletGenerator only generates variation with repeating for given
input.

DistanceResolver counts distances between two states and distance
of path.

AoICoverageResolver determines cost function for states,where all
UAVs are in AoIs.

GuidingPathFactory is wrapper for PathFindingAlgorithm interface and
is used by Core to find guiding path. 

Implementation of PathFindingAlgorithm is AStart class.

\bibliographystyle{plainnat}
\phantomsection\addcontentsline{toc}{chapter}{\bibname}\bibliography{bibliography}


\cleardoublepage{}
\end{document}
